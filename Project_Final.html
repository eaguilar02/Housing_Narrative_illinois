<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Housing Prices v. Household Income in Illinois</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: 'Trebuchet MS', sans-serif; margin:0; padding-bottom:6%; }

    hr.fancy{ 
      width:70%; 
      opacity:.3;
      height:1px;
      background-image:linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,.75), rgba(0,0,0,0)); }
    
    h1{
      margin:25px 0 20px 20%;
      font-weight:bold; }

    p.author{ margin-left:20%; }
    
    #bucket-chart{ width: 820px; margin: 20px; }
    
    .tooltip{
      position: fixed; pointer-events:none; background:#111; color:#fff;
      padding:6px 8px; border-radius:4px; font-size:12px; opacity:0; transition:opacity .15s;
    }
    
    #myProgress{
      width: 820px; height: 8px; background:#eee; border-radius:4px;
      overflow:hidden; margin: 10px 20px;
    }
    #myBar{
      height:100%; width:0%; background:#726f72;
      transition: width .6s linear; 
    }

    .b {
      width: 3%;
      background-color:rgb(71, 64, 66);
      color: whitesmoke;
      border-radius: 100%;
      font-weight: bold;
      padding: 1em;
      border: none;
    }

    .b:hover {
      background: rgb(3, 3, 3);
      color: rgb(202, 202, 202);
      cursor: pointer;
      transition: background 0.5s;
    }
    .toggle{
      background-color:rgb(71, 64, 66);
    }
    .toggle:hover {
      background: rgb(3, 3, 3);
      color: rgb(231, 229, 229);
      cursor: pointer;
      transition: background 0.5s;
    }
    
    .grid line {
      stroke: #e9e9ee;
      stroke-opacity: 1;
      shape-rendering: crispEdges;
    }
    .grid path { display: none; }

    /* prediction outlines + labels */
    .outline { fill: none; pointer-events:none; }
    .outline.guess { stroke:#cd3c3c; stroke-width:3; }
    .outline.actual{ stroke:#4fcf4d; stroke-width:3; }
    .pill{ padding:2px 6px; border-radius:6px; font-size:12px; }
    .pill.guess{ background:#fde9cf; color:#8a5a10; }
    .pill.actual{ background:#f9d6d5; color:#7d1d1a; }

    .anno-group text.anno-title { font-weight: 700; }
    .anno-group text.anno-body  { font-size: 12px; fill:#444; }
    .anno-callout { stroke:#444; stroke-width:1; fill:none; }
    .anno-box { fill:#fff; stroke:#bbb; stroke-width:1; rx:3; ry:9; }

    p{font-weight: lighter;
    font-family: Georgia, 'Times New Roman', Times, serif;}
  </style>
</head>
<body>

  <h1>Housing Prices v. Household Income in Illinois</h1>
  <hr class="fancy" />
  <p class="author">Emily Aguilar, 2025</p>
  <hr class="fancy" />
  <br>
  <div style="width:70%;margin-left: 10%;">
    <p style="margin:2% 0 0 20%;">This project examines the growing gap between median income and home prices in Illinois from 2014 to 2023. It allows users to explore household income distribution over this period and compare it to the income needed to afford a home, calculated using the 3× affordability rule. Users can also examine the distribution of individual wages within Illinois for additional context. The goal of this analysis is to shed light on the potential challenges posed by rising housing prices outpacing household income growth.</p>
  </div>

  <div id="bucket-chart" style="margin-left: auto;margin-right: auto; margin-top: 3%;"></div>
  <div class="tooltip" id="tooltip"></div>
  
  <div class="container" style="position:relative;">
    <button class="b" onclick="plusSlides(-1)" style="position:absolute;top:-25%;right:70%;margin-top: 10%;z-index: 1000;">&#10094;</button>

    <div id="myProgress" style="margin-left: auto; margin-right: auto;">
      <div id="myBar"></div>
    </div>

    <button class="b" onclick="plusSlides(1)" style="position:absolute;top:-25%;right:28%;margin-top: 10%;z-index: 1000;">&#10095;</button>
    
    <button id="toggleBtn" class="toggle" style="position:relative;border:none;padding:1em;border-radius: 10%;margin-left: 47%;margin-top: 2%;color: whitesmoke;" type="button" onclick="toggleDataset()">View Wages</button>
  </div>

  <div style="width:820px;margin:40px 32% auto; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
    <strong>Year: <span id="yearLabel">—</span></strong>
    <input id="guess" type="number" placeholder="Guess required income (e.g., 65000)" style="width:220px;">
    <button id="guessBtn" class="toggle" style="color:white; border:none; padding:.55em .9em; border-radius:8px;">Submit Guess</button>
    <button id="clearBtn" style="border:1px solid #bbb; background:white; padding:.5em .8em; border-radius:8px;">Clear</button>
    <span id="msg" style="margin-left:6px; font-weight:600;"></span>
  </div>

  <script>
    // --- layout ---
    const margin = {top: 10, right: 150, bottom: 100, left: 40},
          width  = 1000 - margin.left - margin.right,
          height = 520 - margin.top - margin.bottom;
    
    const svg = d3.select("#bucket-chart").append("svg")
      .attr("width",  width  + margin.left + margin.right)
      .attr("height", height + margin.top  + margin.bottom)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);
    
    const tip = d3.select("#tooltip");
    const x = d3.scaleBand().range([0, width]).padding(0.15);
    const y = d3.scaleLinear().range([height, 0]);
    const xAxisG = svg.append("g").attr("transform", `translate(0,${height})`);
    const yAxisG = svg.append("g");
    const barsG  = svg.append("g");
    const outlinesG = svg.append("g"); 
    const labelsG   = svg.append("g");
    const annG = svg.append("g").attr("class","anno-group"); 
    const xGridG = svg.append("g").attr("class", "grid x-grid");
    const yGridG = svg.append("g").attr("class", "grid y-grid");
    
    const yLabel = svg.append("text")
      .attr("x", -height/2).attr("y", -40)
      .attr("transform", "rotate(-90)")
      .attr("text-anchor", "middle")
      .text("Share of Households");
    
    const titleText = svg.append("text")
      .attr("x", width/2).attr("y", height + 85)
      .attr("text-anchor", "middle");

    // --- data holders ---
    let householdDataByYear = new Map();
    let wageDataByYear = new Map();
    let affordabilityByYear = new Map(); // Year -> {Year, RequiredIncome, AvgHomeValue}
    let years  = [];
    let yearIdx = 0;
    let useHouseholdData = true; // start with Household (Illinois)
    let currentYearData = [];    // bars currently rendered (for outlines)

    const LABELS = {
      household: { unitPlural: "Households" },
      wage:      { unitPlural: "Workers" }
    };

    const URL1 = "https://raw.githubusercontent.com/eaguilar02/Housing_Narrative_illinois/main/HouseholdIncome.csv";
    const URL2 = "https://raw.githubusercontent.com/eaguilar02/Housing_Narrative_illinois/main/Wage%20Distribution.csv";
    const AFF_URL = "https://raw.githubusercontent.com/eaguilar02/Housing_Narrative_illinois/main/Affordability%20-%20Sheet1.csv";
    const STATE = "Illinois";



    // --- Annotation helpers ---
function barCenterX(bucketLabel){
  const x0 = x(bucketLabel);
  if (x0 == null) return null;
  return x0 + x.bandwidth()/2;
}
function barTopY(bucketLabel){
  const rec = currentYearData.find(d => d.bucket === bucketLabel);
  if (!rec) return null;
  return y(rec.share); // top of the bar
}

    function drawAnnotation({ anchorType, bucket, title, body, dx=0, dy=-18 }) {
      // Choose anchor (where the callout points)
      let ax = null, ay = null;
      if (anchorType === "bucketTop" && bucket){
        const domain = x.domain();
        const matched = findBucketLabelApprox(bucket, domain);
        if (matched){
          ax = barCenterX(matched);
          ay = barTopY(matched);
        } else {
          // fallback: point to the largest bar so the note still shows
          const maxRec = currentYearData.reduce((a,b)=> (a && a.share > b.share) ? a : b, null);
          if (maxRec){
            ax = barCenterX(maxRec.bucket);
            ay = y(maxRec.share);
            console.warn(`Annotation bucket not found for year ${document.getElementById("yearLabel").textContent}:`, bucket);
          }

        }
      }
      if (anchorType === "maxShare"){
        const maxRec = currentYearData.reduce((a,b)=> (a && a.share > b.share) ? a : b, null);
        if (maxRec){ ax = barCenterX(maxRec.bucket); ay = y(maxRec.share); }
      }




      if (ax == null || ay == null) return; // if bucket not in this year

      // Text box position
      const tx = ax + dx;
      const ty = ay + dy;

      // Group for one annotation
      const g = annG.append("g");
      annG.raise();

      // Callout line
      g.append("path")
        .attr("class","anno-callout")
        .attr("d", `M${ax},${ay} L${tx},${ty}`);

      // Text box (size after text measured; we’ll use a simple padding)
      const padX = 5, padY = 6;
      const textG = g.append("g");

      const titleText = textG.append("text")
        .attr("class","anno-title")
        .attr("x", tx).attr("y", ty)
        .text(title || "");

      const bodyText = textG.append("text")
        .attr("class","anno-body")
        .attr("x", tx).attr("y", ty + 16)
        .text(body || "");

      // measure
      const bboxTitle = title ? titleText.node().getBBox() : {width:0,height:0};
      const bboxBody  = body  ? bodyText.node().getBBox()  : {width:0,height:0};
      const w = Math.max(bboxTitle.width, bboxBody.width) + padX*2;
      const h = (title?bboxTitle.height:0) + (body?bboxBody.height:0) + padY*3;

      // box behind text
      g.insert("rect", "g") // insert before text group
        .attr("class","anno-box")
        .attr("x", tx - padX)
        .attr("y", ty - (title?bboxTitle.height:0) - padY)
        .attr("width", w)
        .attr("height", h);
    }

    // Clear and draw annotations for a specific year
    function drawAnnotationsForYear(year){
      annG.selectAll("*").remove();
      const annos = ANNOTATIONS[year];
      if (!annos) return;
      annos.forEach(a => drawAnnotation(a));
    }

const ANNOTATIONS = {
  2016: [
    {
      anchorType: "maxShare",
      title: "Starting point (2016)",
      body:  "Most households are concentrated in this income range.",
      dx: 40, dy: 35
    }
  ],
  2018: [
    {
      anchorType: "bucketTop",
      bucket: "$50,000 – $59,999", 
      title: "Mid-income pressure",
      body:  "Affordability begins to tighten here.",
      dx: -140, dy: -50
    }
  ],
  2023: [
    {
      anchorType: "bucketTop",
      bucket: "$100,000 – $124,999", 
      title: "2023 snapshot",
      body:  "Higher incomes are more common, but homes still outpace income.",
      dx: -45, dy: -60
    }
  ],2014: [
    {
      anchorType: "bucketTop",
      bucket: "$45,000 – $49,999", 
      title: "2014 Recovery from Subprime Mortgage Crisis",
      body:  ["House prices start to rise statewide", "following the financial crisis in 2008 in the US. "],
      dx: -45, dy: -60
    }
  ]
};

function normLabel(s){
  return String(s).toLowerCase()
    .replace(/[\s\u2013\u2014-]+/g, '-') // normalize spaces & dashes to single '-'
    .replace(/[,]/g, '')                 // drop commas
    .replace(/\$/g, '')                  // drop dollar signs
    .trim();
}
function findBucketLabelApprox(targetLabel, domainLabels){
  const t = normLabel(targetLabel);
  // exact normalized match
  let hit = domainLabels.find(lbl => normLabel(lbl) === t);
  if (hit) return hit;
  // starts-with / contains fallback
  hit = domainLabels.find(lbl => normLabel(lbl).includes(t) || t.includes(normLabel(lbl)));
  return hit || null;
}



    // Normalize both CSVs into the same shape -> { Year, bucketId, bucket, share, count, geo }
    function normalize(rows, kind) {
      return rows.map(d => {
        const bucketId = kind === "household" ? +d["Household Income Bucket ID"] : +d["Wage Bin ID"];
        const bucket   = kind === "household" ? d["Household Income Bucket"]     : d["Wage Bin"];
        const count = d.Household_Income != null ? +d.Household_Income : null;
        return { Year: +d.Year, bucketId, bucket, share: +d.share, count, geo: d.State };
      });
    }

    // --- Load all three data files ---
    Promise.all([ d3.csv(URL1), d3.csv(URL2), d3.text(AFF_URL) ])
      .then(([householdRows, wageRows, affordText]) => {
        // Household & Wage
        const hNorm = normalize(householdRows, "household").filter(d => d.geo === STATE);           // Illinois
        const wNorm = normalize(wageRows, "wage").filter(d => d.geo === "United States");           // national (as before)

        d3.groups(hNorm, d => d.Year).forEach(([yr, arr]) => {
          householdDataByYear.set(yr, arr.sort((a,b) => d3.ascending(a.bucketId, b.bucketId)));
        });
        d3.groups(wNorm, d => d.Year).forEach(([yr, arr]) => {
          wageDataByYear.set(yr, arr.sort((a,b) => d3.ascending(a.bucketId, b.bucketId)));
        });

        // Affordability CSV is one long line -> fix, then parse
        let fixed = affordText
          .replace(/\r/g, '')
          .replace(/(3x Affordability Rule),/i, '$1\n') // newline after header
          .replace(/(\s)(?=\d{4},)/g, '\n')             // newline before each "YYYY,"
          .trim();

        d3.csvParse(fixed).forEach(r => {
          const Year = +r["Years"];
          if (!Number.isFinite(Year)) return;
          affordabilityByYear.set(Year, {
            Year,
            AvgHomeValue: +r["Average of Home Value in Illinois"],
            RequiredIncome: +r["3x Affordability Rule"]
          });
        });

        const hYears = new Set(Array.from(householdDataByYear.keys()));
        const wYears = new Set(Array.from(wageDataByYear.keys()));
        const aYears = new Set(Array.from(affordabilityByYear.keys()));
        years = Array.from(new Set([...hYears, ...wYears, ...aYears])).sort(d3.ascending);

        const MIN_YEAR = 2014, MAX_YEAR = 2023;
        years = years.filter(y => y >= MIN_YEAR && y <= MAX_YEAR);

        if (years.length === 0) {
          svg.append("text")
            .attr("x", width/2).attr("y", height/2)
            .attr("text-anchor", "middle")
            .text("No data between 2014 and 2023.");
          return;
        }

        const startYear = years.includes(MIN_YEAR) ? MIN_YEAR : years[0];
        yearIdx = Math.max(0, years.indexOf(startYear));

        update(years[yearIdx], false);
        refreshToggleButton();

      })
      .catch(err => {
        console.error("Data load failed:", err);
        svg.append("text")
          .attr("x", width/2).attr("y", height/2)
          .attr("text-anchor", "middle")
          .text("Failed to load CSV. Check console.");
      });

    function update(year, animate = true) {
      const dataMap = useHouseholdData ? householdDataByYear : wageDataByYear;
      const data = dataMap.get(year) || [];
      currentYearData = data; 

      document.getElementById("yearLabel").textContent = year ?? "—";
      document.getElementById("msg").textContent = "";
      clearHighlights(); 

      titleText.text(`${useHouseholdData ? "Household Income" : "Wage"} Distribution (Year ${year})`);
      yLabel.text(`Share of ${useHouseholdData ? LABELS.household.unitPlural : LABELS.wage.unitPlural}`);

      x.domain(data.map(d => d.bucket));
      y.domain([0, d3.max(data, d => d.share) || 1]).nice();

      const t = animate ? svg.transition().duration(600) : svg;

      xAxisG.transition(t).call(d3.axisBottom(x))
        .selectAll("text")
          .attr("text-anchor","end")
          .attr("transform","rotate(-35)")
          .attr("dx","-0.5em")
          .attr("dy","0.25em");
      yAxisG.transition(t).call(d3.axisLeft(y).tickFormat(d3.format(".0%")));

      xGridG.attr("transform", `translate(0,${height})`)
            .transition(t).call(d3.axisBottom(x).tickSize(-height).tickFormat(""));
      yGridG.transition(t).call(d3.axisLeft(y).tickSize(-width).tickFormat(""));
      xGridG.lower(); yGridG.lower();

      const bars = barsG.selectAll("rect")
        .data(data, d => d.bucket);

      bars.join(
        enter => enter.append("rect")
          .attr("x", d => x(d.bucket))
          .attr("y", y(0))
          .attr("width", x.bandwidth())
          .attr("height", 0)
          .attr("fill", "#3783D4")
          .on("mousemove", (event, d) => {
            tip.style("opacity", 1)
               .style("left", (event.clientX + 12) + "px")
               .style("top",  (event.clientY + 12) + "px")
               .html(
                 `<strong>${d.bucket}</strong><br>` +
                 `Share Percentage: ${d3.format(".1%")(d.share)}<br>` +
                 (d.count != null
                   ? `Total number of ${useHouseholdData ? LABELS.household.unitPlural : LABELS.wage.unitPlural}: ${d3.format(",d")(d.count)}`
                   : ``)
               );
          })
          .on("mouseleave", () => tip.style("opacity", 0))
          .transition(t)
            .attr("y", d => y(d.share))
            .attr("height", d => height - y(d.share)),
        update => update.transition(t)
          .attr("x", d => x(d.bucket))
          .attr("y", d => y(d.share))
          .attr("width", x.bandwidth())
          .attr("height", d => height - y(d.share)),
        exit => exit.transition(t)
          .attr("y", y(0))
          .attr("height", 0)
          .remove()
      );

      setProgressByIndex();
      drawAnnotationsForYear(year);

    }

    // --- prediction on SAME chart ---
    function clearHighlights(){
      outlinesG.selectAll("*").remove();
      labelsG.selectAll("*").remove();
    }
    function outlineBar(bucketLabel, cls, text){
      const rec = currentYearData.find(d => d.bucket === bucketLabel);
      if (!rec) return;
      const rx = x(rec.bucket);
      const ry = y(rec.share);
      const rw = x.bandwidth();
      const rh = height - ry;

      outlinesG.append("rect")
        .attr("class", `outline ${cls}`)
        .attr("x", rx).attr("y", ry)
        .attr("width", rw).attr("height", rh);

      labelsG.append("text")
        .attr("x", rx + rw/2).attr("y", Math.max(ry - 8, 12))
        .attr("text-anchor","middle")
        .style("font-size","12px")
        .text(text);
    }

    function parseBucketRange(label){
      const s = label.replace(/\s/g,'');
      if (/^<\$\d/.test(s)) {
        const hi = +s.replace(/^<\$/,'').replace(/[,$]/g,'');
        return [0, hi];
      }
      if (/\+$/.test(s)) {
        const lo = +s.replace(/[$,]/g,'').slice(0, -1);
        return [lo, Infinity];
      }
      const m = s.match(/\$?([\d,]+)[–-]\$?([\d,]+)/);
      if (m) {
        const lo = +m[1].replace(/,/g,'');
        const hi = +m[2].replace(/,/g,'');
        return [lo, hi];
      }
      return [NaN, NaN];
    }
    function bucketForIncome(value, domainLabels){
      for (const lbl of domainLabels){
        const [lo, hi] = parseBucketRange(lbl);
        if (!Number.isNaN(lo)) {
          if (value >= lo && value <= hi) return lbl;
          if (hi === Infinity && value >= lo) return lbl;
        }
      }
      return null;
    }

    // --- controls ---
    function setProgressByIndex() {
      const pct = years.length > 1 ? ((yearIdx + 1) / years.length) * 100 : 100;
      document.getElementById('myBar').style.width = pct + '%';
    }
    function plusSlides(n) {
      if (!years.length) return;
      yearIdx = (yearIdx + n + years.length) % years.length;
      update(years[yearIdx]);
    }
    function currentSlide(n) {
      if (!years.length) return;
      yearIdx = Math.min(Math.max(0, n - 1), years.length - 1);
      update(years[yearIdx]);
    }
    function toggleDataset() {
      useHouseholdData = !useHouseholdData;
      refreshToggleButton();
      update(years[yearIdx], false);
    }
    function refreshToggleButton() {
      const btn = document.getElementById('toggleBtn');
      if (!btn) return;
      btn.textContent = useHouseholdData ? 'View Wages' : 'View Household Income';
    }

    window.plusSlides = plusSlides;
    window.currentSlide = currentSlide;
    window.toggleDataset = toggleDataset;

    // --- guess handlers ---
    document.getElementById("guessBtn").addEventListener("click", () => {
      const msg = document.getElementById("msg");
      msg.textContent = "";
      if (!years.length) return;

      if (!useHouseholdData) {
        msg.textContent = "Switch to Household Income to make an affordability guess.";
        return;
      }

      const year = years[yearIdx];
      const aff = affordabilityByYear.get(year);
      if (!aff) { msg.textContent = "No affordability data for this year."; return; }

      const guessVal = +document.getElementById("guess").value;
      if (!Number.isFinite(guessVal) || guessVal <= 0) { msg.textContent = "Enter a positive number."; return; }

      clearHighlights();

      const labels = x.domain();
      const guessBucket  = bucketForIncome(guessVal, labels);
      const actualBucket = bucketForIncome(aff.RequiredIncome, labels);

      if (!guessBucket)  { msg.textContent = "Guess is outside the bucket labels."; return; }
      if (!actualBucket) { msg.textContent = "Actual value is outside the bucket labels for this view."; return; }

      outlineBar(guessBucket,  "guess",  `Your guess: ${d3.format(",d")(guessVal)}`);
      outlineBar(actualBucket, "actual", `Actual: ${d3.format(",d")(aff.RequiredIncome)}`);

      const err = guessVal - aff.RequiredIncome;
      const pct = err / aff.RequiredIncome;
      msg.innerHTML = `<span class="pill actual">Actual</span> ${d3.format(",d")(aff.RequiredIncome)} &nbsp; • &nbsp; <span class="pill guess">Your guess</span> ${d3.format(",d")(guessVal)} &nbsp; • &nbsp; Error: ${d3.format("+,d")(err)} (${d3.format("+.1%")(pct)})`;
    });

    document.getElementById("clearBtn").addEventListener("click", () => {
      clearHighlights();
      document.getElementById("msg").textContent = "";
    });
  </script>
</body>
</html>
